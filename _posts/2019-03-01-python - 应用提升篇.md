---
layout:     post
title:      python3 - 应用提升
subtitle:   一些常用的应用模块和功能
date:       2019-03-01
author:     LOLITA0164
header-img: img/post-bg-python.jpg
catalog: true
tags: 
    - python3
---



## CGI 编程

CGI(Common Gateway Interface)，通用网关接口，它是一段程序，运行在服务器上（如 HTTP服务器），提供客户端的接口作用。

#### 网页浏览

为了更好的了解 CGI 的工作流程，我们以网页点击一个链接为例：

![CGI架构图](https://ws3.sinaimg.cn/large/006tKfTcgy1g0stet3mvsj30dw0af74k.jpg)

1. 使用浏览器访问 URL 并链接到 HTTP web 服务器。
2. Web 服务器接收到请求信息后回解析 URL，并查找访问的文件在服务器上是否存在，如果存在返回文件的内容，否则返回错误信息。
3. 浏览器从服务器上接收信息，并显示接收的文件或错误信息。

CGI 程序可以是Python脚本、PERL脚本、SHELL脚本，C或者C++程序等。

#### 一个 CGI 程序

```
#!/usr/bin/env python
print("Content-Type: text/html\n")

print("Hello World!!!")
```

上述脚本是一个简单的Python脚本，第一行输出的内容`Content-Type: text/html\n`发送到浏览器并告知浏览器显示的内容类型为'text/html'。

![访问CGI](https://ws3.sinaimg.cn/large/006tKfTcgy1g0stnlwd40j30k605qwec.jpg)

#### 传递参数

Python中有一个叫做`cgi`的内置库，我们可是使用它来接收参数，无奈是GET还是POST都是一样的。

```
#!/usr/bin/env python
import	cgi
print("Content-Type: text/html\n")

# 创建 FieldStorage 的实例
store = cgi.FieldStorage()
# 获取参数
name = store.getvalue('name')
age = store.getvalue('age')

print("姓名:{0}, 年龄：{1}".format(name,age))
```

访问接口：

![访问接口](https://ws2.sinaimg.cn/large/006tKfTcgy1g0sujeeopkj30tk04c0sm.jpg)

上述例子中都是以文本形式，你也可以修改"Content-Type"类型以 json 形式返回。

```
#!/usr/bin/env python
import	cgi
print("Content-Type: text/json\n")

# 创建 FieldStorage 的实例
store = cgi.FieldStorage()
# 获取参数
name = store.getvalue('name')
age = store.getvalue('age')

import json
dict = {
	"name":name
	"age":age
}
json = json.dumps(dict)
print(json)
```
![json形式](https://ws4.sinaimg.cn/large/006tKfTcgy1g0suids3o3j30w004m3ye.jpg)

#### 使用Cookie

cookie就是在客户访问脚本的同时，通过客户的浏览器，在客户硬盘上写入记录数据，当下次客户访问脚本时取回数据信息，从而达到身份判别的功能，cookie常用在身份校验中。

**cookie语法**

 ```
 Set-cookie:name=name;expires=date;path=path;domain=domain;secure
 ```
 
 - **name=name:** 需要设置cookie的值，有多个name值使用";"分隔，例如：name1=name1;name2=name2。
 - **expires=date:** cookie的有效期限，格式：expires="Wdy,DD-Mon-YYYY HH:MM:SS"
 - **path=path:** 设置cookie支持的路径，如果path是一个路径，则cookie对这个目录下的所有文件及子目录生效。
 - **domain=domain:** 对cookie生效的域名
 - **secure:**如果给出此标志，表示cookie只能通过SSL协议的https服务器来传递。
 - cookie的接收是通过设置环境变量 HTTP_COOKIE 来实现的，CGI程序可以通过检索该变量获取cookie信息。


**设置cookie**

```
#!/usr/bin/env python
import	cgi
print ('Content-Type: text/html')
print ('Set-Cookie: name="xiaoming";expires=Wed, 28 Aug 2018 18:30:00 GMT\n')

print("Cookie set OK!")
```
 
![设置cookie](https://ws3.sinaimg.cn/large/006tKfTcgy1g0suwx03cyj30lo048t8k.jpg)
 
**检索cookie**
 
```
 #!/usr/bin/env python
import os
import http.cookies
print ('Content-Type: text/html\n')

if 'HTTP_COOKIE' in os.environ:
	cookie_string = os.environ.get('HTTP_COOKIE')
	c = http.cookies.SimpleCookie()
	c.load(cookie_string)

	try:
		data = c['name'].value
		print ("cookie data:{}".format(data))
	except :
		print ("cookie 没有设置或者已经过期")
else:
	print ("HTTP_COOKIE 无")
```
 
 
----
 
 
## MySQL
 
#### mysql-connector
 
mysql-connector 是 MySQL 官方提供的驱动器。我们可以使用 **pip** 命令来安装 **mysql-connector**:
 
```
python -m pip install mysql-connector
```
 
**数据库连接**

```
import mysql.connector
 
mydb = mysql.connector.connect(
  host="localhost",       # 数据库主机地址
  user="yourusername",    # 数据库用户名
  passwd="yourpassword"   # 数据库密码
)
```

**cursor()**

可以使用cursor()方法创建一个游标对象cursor，我们可以使用他来进行一些数据库操作。

```
mycursor = mydb.cursor()
```

**execute() 方法**

游标对象有一个execute()方法，用来执行SQL语句。例如我们来查看已存在的数据库信息：

```
mycursor.execute("SHOW DATABASES")
```

**commit() 方法**

对于数据内容有更新的，都必须使用commit()语句来确认本次提交。

```
sql = "INSERT INTO sites (name, url) VALUES (%s, %s)"
val = ("RUNOOB", "https://www.runoob.com")
mycursor.execute(sql, val)
# 确认本次提交
mydb.commit()
```

**rowcount**

操作所影响的记录条数。

```
print(mycursor.rowcount, "记录插入成功。")
```

**fetchall()、fetchone()**

在查询数据时，我们可以使用上述两个方法来获取所有或者一条数据记录。

```
# 执行查询语句
mycursor.execute("SELECT name, url FROM sites")
# 查询所有
myresult1 = mycursor.fetchall()
# 查询单条记录
myresult2 = mycursor.fetchone()
```

#### PyMySQL 
 
PyMySQL 是在 Python3.x 版本中用于连接 MySQL 服务器的库。

你可以使用 pip 安装 PyMySQL：

```
$ pip3 install PyMySQL
```

也可以使用 git 或手动安装

```
$ git clone https://github.com/PyMySQL/PyMySQL
$ cd PyMySQL/
$ python3 setup.py install
```

PyMySQL下的数据库操作与之前非常的相似。

操作数据库的相关实例：

```
#!/usr/bin/python3
 
import pymysql
 
# 打开数据库连接
db = pymysql.connect("localhost","testuser","test123","TESTDB" )
 
# 使用 cursor() 方法创建一个游标对象 cursor
cursor = db.cursor()
 
# 使用 execute()  方法执行 SQL 查询 
cursor.execute("SELECT VERSION()")

# 使用 fetchone() 方法获取单条数据.
data = cursor.fetchone()
 
print ("Database version : %s " % data)
 
# 关闭数据库连接
db.close()
```

**数据查询**

Python查询，mysql使用 'fetchone()' 获取单条数据，使用 'fetchall()' 获取多条数据。

- **fetchone()** : 获取单条记录，查询的结果集是一个对象
- **fetchall()** : 获取所有记录，查询的结果集是数组
- **rowcount** : 返回执行 execute() 后所影响的行数，只读属性

```
# SQL 查询语句
sql = "SELECT * FROM EMPLOYEE \
       WHERE INCOME > %s" % (1000)
try:
   # 执行SQL语句
   cursor.execute(sql)
   # 获取所有记录列表
   results = cursor.fetchall()
   for row in results:
      fname = row[0]
      lname = row[1]
      age = row[2]
      sex = row[3]
      income = row[4]
       # 打印结果
      print ("fname=%s,lname=%s,age=%s,sex=%s,income=%s" % \
             (fname, lname, age, sex, income ))
except:
   print ("Error: unable to fetch data")
 
# 关闭数据库连接
db.close()
```

**事务**

为何需要数据回滚？因为为了确保数据的一致性，及在执行某些操作时候，因为一些原因导致发生了异常，为了保证数据的完整性、一致性，我们需要将数据状态恢复到操作前的状态，即我们所有操作要么都被执行，要么都不被执行，而我们每次做的操作都被称为事务。

事务应该具有4种特性：原子性、一致性、隔离性、持久性。这4种属性通常称为ACID特性。

- 原子性（atomicity）：一个事务是一个不可分割的工作单位，事务中包括的诸多操作要么都做，要么都不做。
- 一致性（consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性和原子性都是密切相关的。
- 隔离性（isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能相互干扰。
- 持久性（durability）：持久性也称为永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

python对事务提供了两个方法：`commit`和`rollback`。这两个方法用来确认和回滚事务。在Python数据库编程中，当游标建立之时，就自动开始了一个隐形的数据库事务。

**commit() 和 rollback()**

在操作数据时，经常会发生一些异常，我们在执行这些更新数据时，可以将其放在 `try/except` 语句中，另外与其对应的，有一个 'rollback()' 回滚的方法，撤销之前一切操作，回到最初的状态。

```
# SQL 插入语句
sql = """INSERT INTO EMPLOYEE(FIRST_NAME,
         LAST_NAME, AGE, SEX, INCOME)
         VALUES ('Mac', 'Mohan', 20, 'M', 2000)"""
try:
   # 执行sql语句
   cursor.execute(sql)
   # 提交到数据库执行
   db.commit()
except:
   # 如果发生错误则回滚
   db.rollback()
 
# 关闭数据库连接
db.close()
```

#### MySQL 教程

有关更多的 MySQL 操作，可以查看菜鸟教程中的 [MySQL 教程](http://www.runoob.com/mysql/mysql-tutorial.html)


----


## 多线程

**线程的一些概念**

每个独立的的线程有一个程序运行入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程的到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。

线程可以被抢占中断，在其他线程正在运行时，线程可以暂时搁置（也称为睡眠）。线程可以被分为内核线程和用户线程。内核线程是由操作系统内核创建和撤销，用户线程不需要内核支持而是在用户程序中实现的线程。

**线程模块**

Python3提供了两个标准库 `_thread` 和`threading`对线程的支持，其中`_thread`模块已经被废弃，它提供了低级别的、原始的线程以及一个简单的锁，它相比于 `threading`模块的功能还是比较有限的。`threading`取代了`_thread`模块，前者除了包含后者的所有方法以外，还提供了其他的方法：

- `currentThread()`: 返回当前的线程变量
- `enumerate()`: 返回一个包含正在运行的线程list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程
- `activeCount()`: 返回正在运行的线程数量
- **`run()`** : 用以表示线程活动的方法
- **`start()`** : 启动线程活动
- **`join([time])`** : 等待至线程中止。这阻塞调用线程直至线程的join()方法被调用中止（正常退出、抛出异常、超时） 
- **`isAlive()`** : 返回线程是否活动
- **`getName()`** : 返回线程名
- **`setName()`** : 设置线程名

实例：

开启一个线程执行任务。

```
import threading
import time

# 为线程定义一个任务
def print_time(delay):
    count = 0
    while count<5:
        time.sleep(delay)
        count += 1
        # 输出当前线程的名称以及时间
        print('{},{}'.format( threading.current_thread().name, time.ctime(time.time()) ))

# 创建线程，target为线程执行的任务，args为任务需要的参数
thread_1 = threading.Thread( target=print_time, name="Thread-1", args=(3,) )

thread_1.start()
thread_1.join()
```

输出结果：

```
Thread-1,Wed Mar  6 16:06:36 2019
Thread-1,Wed Mar  6 16:06:39 2019
Thread-1,Wed Mar  6 16:06:42 2019
Thread-1,Wed Mar  6 16:06:45 2019
Thread-1,Wed Mar  6 16:06:48 2019
```

接下来我们开始两个线程来执行任务，演示一下`join()`的作用，首先是同时开启任务。

```
# 创建线程，target为线程执行的任务，args为任务需要的参数
thread_1 = threading.Thread( target=print_time, name="Thread-1", args=(3,) )
thread_2 = threading.Thread( target=print_time, name="Thread-2", args=(2,) )

thread_1.start()
thread_2.start()
thread_1.join()
thread_2.join()

print("任务结束。")
```

输出结果：

```
Thread-2,Wed Mar  6 17:23:30 2019
Thread-1,Wed Mar  6 17:23:31 2019
Thread-2,Wed Mar  6 17:23:32 2019
Thread-1,Wed Mar  6 17:23:34 2019
Thread-2,Wed Mar  6 17:23:34 2019
Thread-2,Wed Mar  6 17:23:36 2019
Thread-1,Wed Mar  6 17:23:37 2019
Thread-2,Wed Mar  6 17:23:38 2019
Thread-1,Wed Mar  6 17:23:40 2019
Thread-1,Wed Mar  6 17:23:43 2019
任务结束。
```

我们发现`join()`阻塞了当前主线程，直至thread_1和thread_2的任务完成。如果你不使用`join()`方法，`print("任务结束。")`将会被优先执行。

我们交换一些位置，就像下面这样：

```
thread_1.start()
thread_1.join()

thread_2.start()
# thread_2.join()

print("任务结束。")
```

输出结果为：

```
Thread-1,Wed Mar  6 17:27:04 2019
Thread-1,Wed Mar  6 17:27:07 2019
Thread-1,Wed Mar  6 17:27:10 2019
Thread-1,Wed Mar  6 17:27:13 2019
Thread-1,Wed Mar  6 17:27:16 2019
任务结束。
Thread-2,Wed Mar  6 17:27:18 2019
Thread-2,Wed Mar  6 17:27:20 2019
Thread-2,Wed Mar  6 17:27:22 2019
Thread-2,Wed Mar  6 17:27:24 2019
Thread-2,Wed Mar  6 17:27:26 2019
```

**线程安全**

在多线程编程时，如果多个线程共同对某个数据修改，则可能出现不可预料的结果，就像下面这样。

```
import threading
import time

# 定义一个全局共用的数据
count = 10

# 为线程1定义 +1 任务
def addOne():
    global count
    for i in range(5):
        count += 1
        print('{},{}'.format(threading.current_thread().name, count))
        time.sleep(1)

# 为线程2定义 -1 任务
def reduceOne():
    global count
    for i in range(5):
        count -= 1
        print('{},{}'.format(threading.current_thread().name, count))
        time.sleep(2)

thread_1 = threading.Thread(target=addOne, name="thread-1")
thread_2 = threading.Thread(target=reduceOne, name="thread-2")

thread_1.start()
thread_2.start()
```

输出的结果：

```
thread-1,11
thread-2,10
thread-1,11
thread-2,10
thread-1,11
thread-1,12
thread-2,11
thread-1,12
thread-2,11
thread-2,10
```
为了保证数据的正确性，需要对多个线程进行同步。
 
Python中，使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，分别对应锁的两种状态--锁定和未锁定，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。
 
```
import threading
import time

# 定义一个全局共用的数据
count = 10

# 创建锁
threadLock = threading.Lock()

# 为线程1定义 +1 任务
def addOne():
    global count
    # 锁定
    threadLock.acquire()
    for i in range(5):
        count += 1
        print('{},{}'.format(threading.current_thread().name, count))
        time.sleep(1)
    # 释放锁
    threadLock.release()

# 为线程2定义 -1 任务
def reduceOne():
    global count
    # 锁定
    threadLock.acquire()
    for i in range(5):
        count -= 1
        print('{},{}'.format(threading.current_thread().name, count))
        time.sleep(2)
    # 释放锁
    threadLock.release()

thread_1 = threading.Thread(target=addOne, name="thread-1")
thread_2 = threading.Thread(target=reduceOne, name="thread-2")

thread_1.start()
thread_2.start()
```

输出结果为：

```
thread-1,11
thread-1,12
thread-1,13
thread-1,14
thread-1,15
thread-2,14
thread-2,13
thread-2,12
thread-2,11
thread-2,10
```

结果正确。在线程1进行加1操作时，线程锁锁定，线程2只能等待，等到线程1的锁被释放后，线程2继续进行减1操作。

**Queue 线程优先级队列**

Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括 FIFO（先来先服务）的队列，LIFO（后入先出LifoQueue）队列以及优先级队列（PriorityQueue）。

这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程的同步。




## 说明

以上内容均来自[菜鸟教程](http://www.runoob.com/python3/)，更多内容可继续查阅相关资料。

感谢菜鸟教程的无私奉献！












