---
layout:     post
title:      iOS 动画篇 - UIKit动画
subtitle:   UIKit动画
date:       2018-11-27-iOS 
author:     LOLITA0164
header-img: img/post-bg-animation.jpg
catalog: true
tags: 
    - iOS
    - 动画
---

## 简单使用篇

#### 简介

iOS10带来了很多新特性，其中有个 `UIViewPropertyAnimator` 类，光从名字上就可以看出，这是一个操作属性动画的类。实际上，这个类能够让我们对视图进行动画控制，我们除了可进行正常的运行动画，如开始、暂停、重启等操作动画，还可以将动画转换为交互式动画，任意的控制时间。

它可以对视图的可动画属性进行操作，例如frame，center，alpha 和 transform等，并且可以任意的添加多个动画块和完成块，相比于之前的 UIView 动画，它改变了我们习惯的动画流程，变得更加灵活。

#### 简单例子

改变一个视图的 center 动画：

```
// 创建动画器
UIViewPropertyAnimator* animator = [[UIViewPropertyAnimator alloc] initWithDuration:1.0
                                                                              curve:UIViewAnimationCurveEaseOut
                                                                         animations:^{
    self.contentView.center = self.view.center;
}];
// 开始动画
[animator startAnimation];
```

![移动位置的动画](https://ws3.sinaimg.cn/large/006tNbRwgy1fxnr35adqsg308w03uglk.gif)

在使用 UIViewPropertyAnimator 做动画时，需要关注下面几个点：

- 包含改变一个或多个视图属性的动画块
- 用于定义动画运行过程中的时间速率曲线
- 动画的持续时间（以秒为单位）
- 动画完成块（可选）

在上面的简单实例中，我们在1秒的时间内，改变了视图的中心位置，其中动画块即为 animations 的代码块，在此代码块中我们可以针对可动动规划进行新增改变。对于运行的动画时间速率，动画器 animator 支持 UIKit 动画中的时间速率函数，即linear、ease-in、ease-out等。

一般来说，我们所创建的动画器都是处于非活跃状态，需要手动调用`-startAnimation`将其变为活跃状态执行动画。

#### 初始化动画器

UIViewPropertyAnimator 为我们提供了多个快捷创建动画器的方法。

- 使用内置`时间速率函数`

`-initWithDuration:curve:animations:`

这种方式就是我们节例子中的使用到的创建方法，curve 参数即时间速率函数，其所支持的以下几种：

```
UIViewAnimationCurveEaseInOut //缓进缓出
UIViewAnimationCurveEaseIn //缓进
UIViewAnimationCurveEaseOut //缓出
UIViewAnimationCurveLinear //线性匀速
```

![四种内置时间速率](https://ws2.sinaimg.cn/large/006tNbRwgy1fxntp7ebyxg308w08ygmk.gif)

如果所说 UIKit 提供的速率曲线函数不能够满足你的执行动画的速率要求，你还可以通过自定义来创建自己的速度曲线。

- 使用`三次贝塞尔曲线`

`-initWithDuration:controlPoint1:controlPoint2:animations:`

三次贝塞尔曲线的起点为（0,0）且其终点为（1,1），因此两个控制点的取值范围是(0,1)。

- 使用`基于弹簧的弹性`

`-initWithDuration:dampingRatio:animations:`

`dampingRatio:`所对应的参数叫做阻尼，一般去值为（0，1）较低的阻尼值对应较小阻力和在静止之前更多更大的振荡。反之则阻力大，振荡少而小。例如你想不振荡的情况下平滑的减速动画，就可以指定值为1。

```
// 创建动画器
UIViewPropertyAnimator* animator = [[UIViewPropertyAnimator alloc] initWithDuration:1.0
                                                                       dampingRatio:0.35
                                                                         animations:^{
    self.contentView.center = CGPointMake(self.view.center.x+100, self.view.center.y);
}];
// 开始动画
[animator startAnimation];
```

![弹性动画](https://ws1.sinaimg.cn/large/006tNbRwgy1fxns6t8wzbg308w042jre.gif) 

- 使用`自定义时间速率对象`

`-initWithDuration:timingParameters:`

该方法需要你提供支持 `UITimingCurveProvider` 协议的对象，如果你要自定义实现此协议，必须提供所有属性的实现。

系统有两个遵循该协议的类

```
UICubicTimingParameters 
UISpringTimingParameters
```
如果你查看`UICubicTimingParameters`类时，你会发现，这个类也只是提供了支持 UIKit 内置的时间速率曲线和三次贝塞尔曲线。类似的`UISpringTimingParameters `也提供了`CASpringAnimation`中的几个物理参数。

示例：我们通过该方法实现一下和上一个方法类似的效果

```
// 弹性的时间速率
UISpringTimingParameters* parameters = [[UISpringTimingParameters alloc] initWithDampingRatio:0.35];
// 创建动画器
UIViewPropertyAnimator* animator = [[UIViewPropertyAnimator alloc] initWithDuration:1.0 timingParameters:parameters];
// 由于该创建方法没有动画块，因此需要自行追加
[animator addAnimations:^{
    self.contentView.center = CGPointMake(self.view.center.x+100, self.view.center.y);
}];
// 开始动画
[animator startAnimation];
```

![弹性的时间速率](https://ws1.sinaimg.cn/large/006tNbRwgy1fxntg4kt4rg308w046jre.gif)


如果说，你受不了每次都需要主动调用`-startAnimation`方法来启动视图动画，还是习惯 UIView 的快捷使用！👌，苹果似乎注意到了这一点，为了适应开发者的习惯，除了上述几种创建动画器的方式，还有一种可以启动开启动画并能返回当前动画器的方法。

- 类方法便捷

`+ runningPropertyAnimatorWithDuration:delay:options:animations:completion:`

该方法提供了动画的几个相对比较重要的参数，如动画执行时间、延迟时间、时间速率、动画块、完成块。该方法兼容了 UIView 动画块的形式。

```
[UIViewPropertyAnimator runningPropertyAnimatorWithDuration:1.0
                                                      delay:0
                                                    options:UIViewAnimationCurveEaseOut
                                                 animations:^{
    self.contentView.center = CGPointMake(self.view.center.x+100, self.view.center.y);
}
                                                 completion:^(UIViewAnimatingPosition finalPosition) {}];
```

![快捷使用](https://ws4.sinaimg.cn/large/006tNbRwgy1fxnu63wgrsg308w04ct8p.gif)

#### 控制动画

UIViewPropertyAnimator 遵守了 UIViewImplicitlyAnimating 协议，而UIViewImplicitlyAnimating 协议是 UIViewAnimating 协议的子类，该类定义了如何控制动画的协议。除了上一节中使用到的`-startAnimation`方法，还有其他几个控制动画的方法。

- 开始执行动画

`-startAnimation`：方法可以启动动画或者在暂停动画后恢复动画。
`-startAnimationAfterDelay:`：和上面方法类似，不过可以指定延迟执行的时间

- 暂停动画

`-pauseAnimation`：暂停动画，当使用该方法后，动画会停留在“当前位置”，会保持当前的状态。暂停后可以使用`-startAnimation`恢复，恢复的动画会从“当前位置”继续剩余的动画，包括剩余的时间。

示例：我们执行一个2秒时长的动画，在1秒处停止，延迟1秒后恢复动画，让其继续执行。

```
UIViewPropertyAnimator* animator = [UIViewPropertyAnimator runningPropertyAnimatorWithDuration:2.0 delay:0 options:UIViewAnimationOptionCurveLinear animations:^{
    self.contentView.center = CGPointMake(self.view.center.x+100, self.view.center.y);
} completion:nil];
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    // 暂停当前动画
    [animator pauseAnimation];
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        // 恢复动画
        [animator startAnimation];
    });
});
```

![动画的暂停和恢复](https://ws3.sinaimg.cn/large/006tNbRwgy1fxnwz9xjd3g308w042dg3.gif)

- `stopAnimation:`：停止动画

停止动画有多种情况，由于动画状态的机制（进阶篇会讲）的存在，当我们停止动画后，这些动画状态信息何去何从？苹果给出了两种的去处，一种时清除所有状态信息，动画器重置为初始的非活跃状态，以等待下一个动画；另外一种是保留所有状态信息，等待下一步操作。这里的 withoutFinishing 参数就是用来指明去处。

参数 withoutFinishing，表示是否应执行任何最终操作。如果值为 YES，则会清除任何动画并将动画器重置为非活跃状态，并且不会执行完成块的回调。

示例：我们执行一个2秒的动画，在一秒处停止当前动画，并且在完成块中将视图的背景色更改为红色。

```
UIViewPropertyAnimator* animator = [UIViewPropertyAnimator runningPropertyAnimatorWithDuration:2.0 delay:0 options:UIViewAnimationOptionCurveLinear animations:^{
    self.contentView.center = CGPointMake(self.view.center.x+100, self.view.center.y);
} completion:^(UIViewAnimatingPosition finalPosition) {
    // 动画的完成回调
    self.contentView.backgroundColor = UIColor.redColor;
}];
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    [animator stopAnimation:YES];
});
```

![withoutFinishing为YES的情况](https://ws3.sinaimg.cn/large/006tNbRwgy1fxnxl082ufg308w03wjre.gif)

运行结果发现，动画在1秒处停止了，但是并没变成红色背景，这说明，此时的动画器并不会执行完成块。

当参数为 NO 时，动画器状态为 stopped，此时通常会配合`finishAnimationAtPosition：`使用，该方法可以帮助动画器执行最终的完成块的内容，当然，这两个方法的目的是停下当前动画，让你完成此刻需要完成的内容，如其他动画，之后，你再使用`finishAnimationAtPosition：`完成动画的回调以及动画需要停止的位置。

在演示示例之前，我们来介绍一下`finishAnimationAtPosition：`。

- `-finishAnimationAtPosition:`：结束动画

该方法可以将处于 stopped 状态的动画重置为非活跃状态，并执行动画的完成块。

此方法通常配合 `-stopAnimation:` 使用，并且该方法必须在动画器状态为 stopped 状态才可以，否则会出现错误。该方法的 `UIViewAnimatingPosition` 参数有一下三种：

```
UIViewAnimatingPositionEnd //动画的终点位置
UIViewAnimatingPositionStart //动画的开头位置
UIViewAnimatingPositionCurrent //动画当前位置
```
指定 UIViewAnimatingPositionCurrent 以使视图属性与其当前值保持不变。

示例：我们继续之前的例子，这次我们配合 `-finishAnimationAtPosition:` 方法使用。

```
UIViewPropertyAnimator* animator = [UIViewPropertyAnimator runningPropertyAnimatorWithDuration:2.0 delay:0 options:UIViewAnimationOptionCurveLinear animations:^{
    self.contentView.center = CGPointMake(self.view.center.x+100, self.view.center.y);
} completion:^(UIViewAnimatingPosition finalPosition) {
    // 动画的完成回调
    self.contentView.backgroundColor = UIColor.redColor;
}];
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    [animator stopAnimation:NO];
    // 动画器的状态必须是stopped
    if (animator.state==UIViewAnimatingStateStopped) {
        [animator finishAnimationAtPosition:UIViewAnimatingPositionCurrent];
    }
});
```

![withoutFinishing为NO的情况](https://ws1.sinaimg.cn/large/006tNbRwgy1fxo01lu6ctg308w03amx6.gif)

我们发现，动画运行1秒后停止了，并且背景色被填充为红色，这说明`-finishAnimationAtPosition:`触发完成块，这一点和之前的例子是不同的。另外，我们看到视图停下来之后就保持在了当前位置，这是因为我们给的结束位置就是 Current。下图演示了位置的不同参数的效果。

![start、current、end三种不同位置](https://ws4.sinaimg.cn/large/006tNbRwgy1fxo0c6nbd4g308w062jrn.gif)

#### 交互式动画

**fractionComplete 属性**

UIViewPropertyAnimator 类中有一个`fractionComplete`属性，这个属性表示当前动画的完成的百分比，并且这个属性不是只读的属性，这说明我们可以精准的控制动画的整个过程。利用它，我们可以制作交互式动画。交互式动画的好处是：对于多个视图、非常复杂的视图变化加以控制变得简单。

示例：

```
@interface ViewController ()
@property (weak, nonatomic) IBOutlet UIView *blueView;
@property (weak, nonatomic) IBOutlet UIView *redView;
@property (weak, nonatomic) IBOutlet UISlider *slider;
@property (strong, nonatomic) UIViewPropertyAnimator* animator;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // 初始化动画器
    self.animator = [[UIViewPropertyAnimator alloc] initWithDuration:2.0 curve:UIViewAnimationCurveLinear animations:^{
        // 红色视图
        CGRect fram = CGRectMake(self.slider.center.x - 50/2.0, self.slider.center.y - 100, 50, 50);
        self.redView.frame = fram;
        self.redView.transform = CGAffineTransformMakeRotation(M_PI);
        self.redView.backgroundColor = UIColor.blueColor;
        // 颜色视图
        self.blueView.frame = fram;
        self.blueView.transform = self.redView.transform;
        self.blueView.backgroundColor = UIColor.redColor;
    }];
    [self.slider addTarget:self action:@selector(change:) forControlEvents:UIControlEventValueChanged];
}

-(void)change:(UISlider*)slider{
    CGFloat value = slider.value;
    // 更改动画完成度
    self.animator.fractionComplete = value;
}
```

![控制两个视图之间的动画](https://ws4.sinaimg.cn/large/006tNbRwgy1fxo2hi1w02g308w0c0wn3.gif)

#### 修改动画



## 进阶篇

#### 动画协议

暂停和延迟开始的错误

动画状态的变换以及停止动画和finishAnimationAtPosition，完成块的使用


#### 修改动画协议


#### 动画器
























