---
layout:     post
title:      iOS 动画篇 - UIKit动画（一）
subtitle:   UIKit动画
date:       2018-11-27-iOS 
author:     LOLITA0164
header-img: img/post-bg-animation.jpg
catalog: true
tags: 
    - iOS
    - 动画
---

在前面文章中，有详细介绍过 [Core Animation 动画](http://luoliang.online/2018/11/19/iOS-%E5%8A%A8%E7%94%BB%E7%AF%87-Core-Animation/),UIKit 动画实质上是针对核心动画的封装，不同的是，核心动画操作的是图层级别（CALayer），通常情况下，它不会影响到视图层，而 UIKit 针对的是视图级别（UIView），我们在做此动画后，视图的 frame、center等属性都会响应的变化。

在入场开发中，UIKit 动画块可以完成百分之九十以上的动画任务，这些动画任务通常是针对视图的可动画属性，例如改变视图的frame、center、bounds、backgroundColor、alpha、transform等等。在某些特殊的情况下（如改变视图的阴影、圆角等），UIKit 完成不了的时候，你依旧可以借助核心动画来完成。

由于 UIKit 动画是核心动画的一层封装，使用起来相比于核心动画要简单很多，关于一些原理的知识，你可以查看 [Core Animation 动画](http://luoliang.online/2018/11/19/iOS-%E5%8A%A8%E7%94%BB%E7%AF%87-Core-Animation/)，此篇文章只做 UIKit 动画的使用介绍。


## UIView 动画

UIView 动画是对 UIView 的分类扩展，是 CABasicAnimation 的封装。你可以使用视图的类方法对任意的视图类做属性动画而无需 Core Animation 那种创建动画实例。

#### begin/commit

在做动画时候，你需要将视图的可动画属性的新值放置在以后两个方法中：

`+beginAnimations:context:`

该方法是动画设置的开始起点，两个参数分别是动画标志符和额外参数

`+commitAnimations`

该方法是动画设置的介绍终点，调用该方法，表示提交当前动画的所有设置，动画入栈，等待 runloop 的执行。

```
// 开始设置动画
[UIView beginAnimations:@"animations" context:nil];
// 可动画属性设置预期的新值
self.blueView.center = self.view.center;
self.blueView.backgroundColor = UIColor.redColor;
// 提交动画
[UIView commitAnimations];
```

![设置动画](https://ws1.sinaimg.cn/large/006tNbRwgy1fxtn0bvooeg308w03o3yc.gif)

在上述例子中，我们改变了视图的中心点位置以及填充色。运行我们发现，视图达到我们预期所设置的新值。但是我们发现，这过程太过短暂，因为上述例子中使用了系统默认的动画时间，即0.2秒。接下来我们通过方法`+setAnimationDuration:`来改变动画的时间。

```
[UIView beginAnimations:@"animations" context:nil];
// 设置动画时间
[UIView setAnimationDuration:1.0];
self.blueView.center = self.view.center;
self.blueView.backgroundColor = UIColor.redColor;
[UIView commitAnimations];
```

![设置动画时间](https://ws4.sinaimg.cn/large/006tNbRwgy1fxtn7hcivxg308w03uq2x.gif)

此时由于动画时长被设置为1秒，使得动画能够平滑动转变为新值。

需要注意的是：设置动画的时长需要放置在属性设置之前，否则无效。动画其他设置大部分都是如此。

类似的，我们还可以使用其他方法来设置我们的动画，其中有：

```
+setAnimationDuration: //动画时长，默认为0.2
+setAnimationDelay: //延迟动画，默认为0.0
+setAnimationStartDate: //指定日期开始动画，默认为当前时间
+setAnimationCurve: //动画的时间速率，默认为UIViewAnimationCurveEaseInOut
+setAnimationRepeatCount: //重复次数，默认为0
+setAnimationRepeatAutoreverses: //是否执行反转动画
+setAnimationsEnabled: //动画执行能力，可关闭动画
```

#### 动画过程

除此之外，如果我们想要监听动画的执行过程事件，该怎么办呢？UIKit 动画为我们提供了三个方法，别分用来设置动画的代理监听对象以及动画的开始和结束事件。

```
+setAnimationDelegate: //设置动画代理
+setAnimationWillStartSelector: //动画开始事件
+setAnimationDidStopSelector: //动画结束事件
```

示例：我们为动画添加代理，实现动画的结束代理方法

```
-(void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    [UIView beginAnimations:@"animations" context:nil];
    [UIView setAnimationDuration:1.0];
    self.blueView.center = self.view.center;
    self.blueView.backgroundColor = UIColor.redColor;
    // 设置动画代理
    [UIView setAnimationDelegate:self];
    // 设置动画开始和结束代理
    [UIView setAnimationWillStartSelector:@selector(start:)];
    [UIView setAnimationDidStopSelector:@selector(end:)];
    [UIView commitAnimations];
}

-(void)start:(NSString*)flag{
//    NSString* tip = [NSString stringWithFormat:@"动画开始-%@",flag];
//    [[[UIAlertView alloc] initWithTitle:@"提示" message:tip delegate:nil cancelButtonTitle:@"确定" otherButtonTitles:nil, nil] show];
}
-(void)end:(NSString*)flag{
    NSString* tip = [NSString stringWithFormat:@"动画结束-%@",flag];
    [[[UIAlertView alloc] initWithTitle:@"提示" message:tip delegate:nil cancelButtonTitle:@"确定" otherButtonTitles:nil, nil] show];
}
```

![动画结束事件](https://ws1.sinaimg.cn/large/006tNbRwgy1fxtogb3jtyg308w05igml.gif)

和其他方法不同，设置动画代理的三个方法只要`begin/commit`之间即可。

#### 转场动画

UIKit 动画中还有一个转场动画，该类通常需要两个或多个视图。

```
+setAnimationTransition:forView:cache:
```

参数 transition：是转场类型，有以下几个：

```
typedef enum UIViewAnimationTransition : NSInteger {
    UIViewAnimationTransitionNone,
    UIViewAnimationTransitionFlipFromLeft,
    UIViewAnimationTransitionFlipFromRight,
    UIViewAnimationTransitionCurlUp,
    UIViewAnimationTransitionCurlDown
} UIViewAnimationTransition;
```

参数 forView：转场动画所应用到的视图

参数 cache：缓存可以提高性能，但如果将此参数设置为YES，则不得在转换期间更新视图或其子视图，因为更新视图及其子视图可能会干扰缓存行为，并导致视图内容在动画期间被错误地（或在错误的位置）呈现，必须等到转换结束才能更新视图。如果为“否”，则必须为过渡动画的每个帧更新视图及其内容，这可能会显着影响帧速率。

如果你想从一个视图翻转到另一个视图，以下为系统提供的步骤：

1. Begin an animation block.

2. Set the transition on the container view.

3. Remove the subview from the container view.

4. Add the new subview to the container view.

5. Commit the animation block.

无非就是对容器视图子视图的移除和添加操作。我们这里例子只有两个视图，因此采用另外方式：做透明度的设置，在翻转的时候隐藏其中一个。

```
[UIView beginAnimations:@"animations" context:nil];
[UIView setAnimationTransition:UIViewAnimationTransitionFlipFromRight forView:self.blueView cache:NO];
self.redView.alpha = !self.redView.alpha;
[UIView setAnimationDuration:1.0];
[UIView commitAnimations];
```

![转场动画](https://ws1.sinaimg.cn/large/006tNbRwgy1fxtp2f7cbsg308w06sgmt.gif)

下面演示了不同的转场动画效果：

![四种不同类型的转场动画](https://ws4.sinaimg.cn/large/006tNbRwgy1fxtrl722hqg308w06sdkq.gif)


上述就是对 UIView 的简单介绍和使用了。正如之前所说的，UIView 动画是对 CABasicAnimation 的封装，它通常只能够对视图属性的可动画属性有效，如果我们想实现例如关键帧，弹性动画等，似乎很困难。另外如果我们想要在一个动画结束之后，紧接着开始另一段动画（甚至更多的动画），我们需在代理方法中加上动画标志符加以区分，或者需要更多的方法选择器指向不同方法，无论是哪一种方式，似乎都加深了代码的复杂度。

出于上述的问题考虑，苹果在 iOS4.0 之后推出了 UIView 动画块，并且强烈推荐开发者使用新的 UIView 动画块来实现视图动画。新的动画方式对之前的动画再次进行了封装，让我们做动画时不在需要进行`begin/commit`以及设置动画属性时调用大量的代码，而采用了诸多的快捷创建方式。另外将动画的完成事件通过block块传递，从而可以一对一的形式传递动画过程。使用动画块的另外一个好处就是我们可在完成块中继续使用新的动画块，从而执行新的动画。

UIView 动画块不仅提供了对 CABasicAnimation 的封装，针对 CAKeyframeAnimation 关键帧动画、CASpringAnimation 弹性动画等都提供了相应的方法，这让我们实现的动画效果变得更多，使用更简便了。


## UIView 动画块



































