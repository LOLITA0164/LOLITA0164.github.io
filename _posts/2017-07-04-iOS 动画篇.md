---
layout:     post
title:      iOS 动画篇
subtitle:   CAAnimation And UIView动画
date:       2017-07-04
author:     LOLITA0164
header-img: img/post-bg-animation.jpg
catalog: true
tags: 
    - iOS
    - 动画
---

## CAAnimation 篇

CAAnimation 是一个抽象动画类。 遵循着 CAMediaTiming 和 CAAciotn 两个协议。 要为 Core Animation 图层或 Scene Kit 对象设置动画，请创建其子类 CABasicAnimation，CAKeyframeAnimation，CAAnimationGroup 或 CATransition 的实例。Core Animation 可以用在 Mac OS X 和 iOS 平台。Core Animation 的动画执行过程都是在后台操作的，不会阻塞主线程。

#### 隐式动画

当你改变 CALayer 的一个可做动画的属性，它并不会立刻在屏幕上呈现出来，而是从先前的值平滑过渡到新值。典型的例子就是改变图层的背景填充色。

示例：

假如我们现在有一个图层，那我们在点击屏幕时尝试去改变此图层的背景填充色。

```
-(void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    // 生成随机颜色
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;
}
```

![隐式动画](https://ws2.sinaimg.cn/large/006tNbRwgy1fxj701fxo9g308w052q33.gif)

我们可以看到，但我们点击屏幕以改变图层的背景时，视图从旧的背景逐渐地过度到了新值。在这过程中，我们没有做其他额外的操作，这种自行完成的平滑过渡动画就是隐式动画。

**事务**

那么这一过程时如何完成的呢？实际上动画是由当前事务来完成的，事务是什么？事务是 Core Animation 用来包含一系列属性动画集合的机制，你可以设置动画的执行时间等，这些动画的图层属性新值的设置都不会立刻发生变化，而是当事务提交时由 run loop 自动开始。

事务是通过 CATransaction 类来管理。该类没有属性或者实例方法，因此你不能创建它，但是你可以通过 `+begin` 和 `commit` 来将当前属性设置分别进行入栈和出栈操作。

任何可以做动画的图层属性都会添加到栈顶的事务，你可以通过 `+setAnimationDuration:` 方法来设置当前事务的动画时间，如果不进行设置，默认的时间是0.25s。

我们现在来显示的完成上一个例子中的动画，并将动画时间延长。


```
-(void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    // 开始一个动画事务
    [CATransaction begin];
    // 设置动画的执行时间
    [CATransaction setAnimationDuration:1.0];
    // 生成颜色，作为动画的变化新值
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;
    // 提交动画事务
    [CATransaction commit];
}
```

![显示动画](https://ws2.sinaimg.cn/large/006tNbRwgy1fxj6x9mx5yg308w0520sz.gif)

我们可以看到图层的动画效果依旧没变，但是渐变的时间明显变长了很多。从代码上看，我们仅仅将图层需要改变的属性加到 `+begin` 和 `commit` 之间，并为此事务设置了一个时间。

如果你使用过 UIView 的动画，那么应该使用过 `+beginAnimations:context:` 和 `+commitAnimations`，实际上这两个都是对 `CATransaction` 的封装，其所做动画都是由 `CATransaction` 完成的。

**完成回调**

`CATranscation ` 的 API 除了提供设置动画时间 `+setAnimationDuration:` 还提供了动画完成的回调方法：`+ setCompletionBlock:`。你可以在该方法中接着完成一些事情。

修改一下代码：

```
-(void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    // 开始一个动画事务
    [CATransaction begin];
    // 设置动画的执行时间
    [CATransaction setAnimationDuration:1.0];
    // 生成颜色，作为动画的变化新值
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;
    // 提交动画事务
    [CATransaction commit];
    // 动画完成回调，可以写在 commit 后面
    [CATransaction setCompletionBlock:^{
        self.colorLayer.affineTransform = CGAffineTransformRotate(self.colorLayer.affineTransform, M_PI_4);
    }];
}
```

![动画完成回调](https://ws3.sinaimg.cn/large/006tNbRwgy1fxj7jvn06hg308w04yjs1.gif)

**图层动画的过程**

当我们给对 CALayer 的属性设新值时，图层经过以下几个过程来检测应该如何呈现新值。

- 图层首先检测它是否有委托者，并且是否实现了协议 `CALayerDelegate` 中的方法 `-actionForLayer:forKey:`，如果有，直接调用并返回结果。
- 如果没有委托者，或者委托没有实现上述方法，图层会检查属性 `actions` 字典，试图找到对应的属性名。
- 如果依旧没有，图层还是检查属性 `style` 字典，再次尝试搜索对应的属性名。
- 最后，如果都未能找到，那么图层直接会调用默认的行为 `defaultActionForKey:` 方法来展现对应属性的新值。

那么，既然我们知道了图层的行为过程，我们是否可以以此做些什么？实际上，我们可以参与图层的行为过程来改变隐式动画的行为。

我们首先通过图层的委托代理完成新的动画过程。

```
@interface ViewController ()
<
    CALayerDelegate
>
@property (strong, nonatomic)CALayer* colorLayer;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.colorLayer = [CALayer layer];
    self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
    self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;
    [self.view.layer addSublayer:self.colorLayer];
    // 设置图层的委托代理
    
    self.colorLayer.delegate = self;
}

// 完成图层行为协议

-(id<CAAction>)actionForLayer:(CALayer *)layer forKey:(NSString *)event{
    // 设置新的动画
    
    CATransition *transition = [CATransition animation];
    transition.type = kCATransitionReveal;
    transition.subtype = kCATransitionFromLeft;
    return transition;
}

-(void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    // 生成随机颜色.
    
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;
}
```

![图层行为1](https://ws2.sinaimg.cn/large/006tNbRwgy1fxj8iqto6dg308w04ymx8.gif)

我们也可以通过 `actions` 字典来完成：

```
@interface ViewController ()
<
    CALayerDelegate
>
@property (strong, nonatomic)CALayer* colorLayer;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.colorLayer = [CALayer layer];
    self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
    self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;
    [self.view.layer addSublayer:self.colorLayer];
    
    // 设置 actions 字典 
    
    CATransition *transition = [CATransition animation];
    transition.type = kCATransitionPush;
    transition.subtype = kCATransitionFromLeft;
    transition.duration = 1.0;  // 动画时间设置稍长
    
    self.colorLayer.actions = @{@"backgroundColor": transition};
}

-(void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    // 生成随机颜色
    
    CGFloat red = arc4random() / (CGFloat)INT_MAX;
    CGFloat green = arc4random() / (CGFloat)INT_MAX;
    CGFloat blue = arc4random() / (CGFloat)INT_MAX;
    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;
}
```

![图层行为2](https://ws2.sinaimg.cn/large/006tNbRwgy1fxj8w84dcug308w04ydg2.gif)

#### 显示动画

和隐式动画相对的，显示动画一般是开发者们主动去实现的动画效果，完成图层从旧状态到新状态到过渡切换。和隐式动画不通，显示动画需要开发者关心动画从产生到消失的每一个细节，如变化的状态、执行的时长、动画的次数等等，相比系统提供的简单的过渡动画效果，显示动画可以完成图层的各种各样的酷炫效果。

**属性动画**

顾名思义，属性动画（CAPropertyAnimation）类的是针对图层的一些可作动画的属性而言的，该类不能直接拿来使用，开发中通常使用其子类（这一点类似手势），如：CABasicAnimation 经典动画、CAKeyframeAnimation 关键帧动画、CASpringAnimation 弹性动画，基础动画的子类。

- CABasicAnimation

CABasicAnimation 动画，需要我们为其提供两个状态值，一个是初始状态值，一个是终止状态值。一般来说，初始值都是图层最初的状态，当然，你也可以指定从初始状态到非终止状态的之间的任意时刻。

示例：

我们接着上面的例子，将图层的圆角值做一些改变。

```
@interface ViewController ()
@property (strong, nonatomic)CALayer* colorLayer;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.colorLayer = [CALayer layer];
    self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
    self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;
    [self.view.layer addSublayer:self.colorLayer];  
}

-(void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
	// 修改圆角属性 
	CABasicAnimation* animation = [CABasicAnimation animationWithKeyPath:@"cornerRadius"];
   animation.toValue = @(self.colorLayer.bounds.size.height/2.0);
   animation.duration = 2;
   animation.autoreverses = YES;   // 执行逆动画 
   [self.colorLayer addAnimation:animation forKey:@"cornerRadius_animation"];
}
```

![经典动画](https://ws4.sinaimg.cn/large/006tNbRwgy1fxjb0aofb3g308w04wmxw.gif)

注：`animationWithKeyPath:` 所带的字符串表示需要修改的 layer 可动画的属性，不是随便写的字符串，一般常用的可动画属性如下：

| key | 说明 |使用样例|
| --- | --- | --- |
|transform.scale| 缩放 |@(0.5)|
|transform.scale.x | 宽的比例 | @(0.5)|
|transform.scale.y|高的比例 | @(0.5)|
|opacity |透明度 |@(0.5)|
|cornerRadius | 圆角的设置  | @(50)|
|transform.rotation.x|围绕x轴旋转 |@(M_PI) |
|transform.rotation.y| 围绕y轴旋转|@(M_PI)|
|transform.rotation.z |围绕z轴旋转|@(M_PI)|
|strokeStart |结合CAShapeLayer使用 |赋值多变|
|strokeEnd|结合CAShapeLayer使用|赋值都变|
|bounds|大小，中心不变 |[NSValue valueWithCGRect:CGRectMake(0, 0, 100, 100)];|
|position| 位置(中心点的改变) |[NSValue valueWithCGPoint:CGPointMake(100, 100)];|
|contents | 内容，| 比如UIImageView的图片    imageAnima.toValue = (id)[UIImage imageNamed:@”imageName”].CGImage;|
| …… |


动画开始和完成事件

和隐式动画中的完成回调不同，CAAnimation 采用了委托模式，因此你如果需要处理动画的开始和完成事件时，你需要完成 CAAnimationDelegate 的代理方法：

```
- (void)animationDidStart:(CAAnimation *)anim;
- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;
```
其中 flag 标识了动画是否是正常结束。另外，事件传递不是完成block块，而是采用委托模式会带来一个问题，就是你有多个动画时，你需要判断当前是那个图层的动画事件。

这里提供两个用来区别的方案。一种就是在添加动画时，`-addAnimation:forKey:` 设置每个动画对应不同的key值，然后通过 `animationKeys` 获取到图层上所有的动画key，然后对每个图层循环所有建，通过 `-animationForKey:` 找到结果。显然这种是非常的麻烦的方式。好在 CAAnimation 实现了 KVC 协议，我们可以像使用字典一样，随意的存取属性。

示例：

我们将图层在完成动画之后，进行背景色的更改。

```
@interface ViewController ()
<
    CAAnimationDelegate
>
@property (strong, nonatomic)CALayer* colorLayer;
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.colorLayer = [CALayer layer];
    self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
    self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;
    [self.view.layer addSublayer:self.colorLayer];  
}

-(void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
	
   CABasicAnimation* animation = [CABasicAnimation animationWithKeyPath:@"cornerRadius"];
   animation.toValue = @(self.colorLayer.bounds.size.height/2.0);
   animation.duration = 2;
   animation.autoreverses = YES;   // 执行逆动画 
   animation.delegate = self;
   // 将视图附加到动画上  
   [animation setValue:self.colorLayer forKey:@"colorLayer"];
   [self.colorLayer addAnimation:animation forKey:@"cornerRadius_animation"];
}

// 动画结束事件 
-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag{
	// 通过key值，取回附加的视图 
   CALayer* layer = [anim valueForKey:@"colorLayer"];
   layer.backgroundColor = UIColor.redColor.CGColor;
}
```

![animation通过KVC附加视图](https://ws4.sinaimg.cn/large/006tNbRwgy1fxjdws6zxkg308w04ymxs.gif)

- CAKeyframeAnimation

相比于经典动画关注于起始和终止的状态值，关键帧动画更注重整个动画过程中多个关键点的状态，因此关键帧动画需要一连串的值来做动画，你甚至可以说，经典动画是关键动画的一种。

```
-(void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    CAKeyframeAnimation* animation = [CAKeyframeAnimation animationWithKeyPath:@"backgroundColor"];
    animation.duration = 4;
    animation.values = @[
                         (__bridge id)UIColor.blueColor.CGColor,
                         (__bridge id)UIColor.redColor.CGColor,
                         (__bridge id)UIColor.yellowColor.CGColor,
                         (__bridge id)UIColor.greenColor.CGColor,
                         (__bridge id)UIColor.blueColor.CGColor
                         ];
    [self.colorLayer addAnimation:animation forKey:nil];
}
```

![关键帧动画](https://ws1.sinaimg.cn/large/006tNbRwgy1fxjeac4uj5g308w04y74p.gif)

上述例子演示了给予关键帧动画的关键位置的数组值，实际上，关键帧还可以是无数个位置，如果此时的动画属性是针对位置一类的，我们就可以将这些关键帧看作是路径，这就演变出了另一种方式做动画，即 `path`。

下面通过移动图层来演示这种方式的关键帧动画：

```
-(void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
	CAKeyframeAnimation* animation = [CAKeyframeAnimation animationWithKeyPath:@"position"];
   animation.duration = 4.0;
   // 关键帧路径
   animation.path = self.path.CGPath;
   [self.imageLayer addAnimation:animation forKey:nil];
}
```

![关键路径](https://ws1.sinaimg.cn/large/006tNbRwgy1fxjfj3tlnng308w04uwf2.gif)

我们的飞船可以沿着关键路径进行移动，但是我们发现飞船的方向一直是横向的，就如最初设置的方向，而不是指向曲线切线的方向。好在苹果发现了这一点，并且给 CAKeyFrameAnimation 添加了一个 rotationMode 的属性，设置它为常量 kCAAnimationRotateAuto，图层将会根据曲线的切线自动旋转。

```
-(void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
   CAKeyframeAnimation* animation = [CAKeyframeAnimation animationWithKeyPath:@"position"];
   animation.duration = 4.0;
   animation.path = self.path.CGPath;
   animation.rotationMode = kCAAnimationRotateAuto;
   [self.imageLayer addAnimation:animation forKey:nil];
}
```

![沿着切线](https://ws1.sinaimg.cn/large/006tNbRwgy1fxjfov890gg308w04wmxn.gif)

- CASpringAnimation





#### 时间


#### 缓冲过度


## UIView 动画

---

2018-11-15 新编





